<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>User Guide &mdash; TorchDR 0.0.0-alpha documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=8e37ee27"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"tex": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Affinity" href="stubs/torchdr.Affinity.html" />
    <link rel="prev" title="Quick Start Guide" href="torchdr.quick_start.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="index.html">
            
              <img src="_static/torchdr_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Torch Dimensionality Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="torchdr.quick_start.html">Quick Start Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dr-general-formulation">DR General Formulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#torch-gpu-support-and-automatic-differentiation">Torch GPU support and automatic differentiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#avoiding-memory-overflows-with-keops-symbolic-lazy-tensors">Avoiding memory overflows with <code class="docutils literal notranslate"><span class="pre">KeOps</span></code> symbolic (lazy) tensors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#affinities">Affinities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-structure">Base structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="stubs/torchdr.Affinity.html">Affinity</a></li>
<li class="toctree-l4"><a class="reference internal" href="stubs/torchdr.LogAffinity.html">LogAffinity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#affinities-based-on-entropic-projections">Affinities based on entropic projections</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-using-entropicaffinity">Examples using <code class="docutils literal notranslate"><span class="pre">EntropicAffinity</span></code>:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-various-affinities">Other various affinities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dr-modules">DR Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="stubs/torchdr.base.DRModule.html">DRModule</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spectral-methods">Spectral methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#affinity-matching-methods">Affinity matching methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="stubs/torchdr.affinity_matcher.AffinityMatcher.html">AffinityMatcher</a></li>
<li class="toctree-l4"><a class="reference internal" href="stubs/torchdr.affinity_matcher.BatchedAffinityMatcher.html">BatchedAffinityMatcher</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mds-like-methods">MDS-like Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#neighbor-embedding">Neighbor Embedding</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="all.html">API and Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="torchdr.releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="torchdr.contributing.html">How to Contribute</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TorchDR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">User Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/torchdr.user_guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-torchdr">
<span id="user-guide"></span><span id="id1"></span><h1>User Guide<a class="headerlink" href="#module-torchdr" title="Link to this heading"></a></h1>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id35">Overview</a></p></li>
<li><p><a class="reference internal" href="#affinities" id="id36">Affinities</a></p></li>
<li><p><a class="reference internal" href="#dr-modules" id="id37">DR Modules</a></p></li>
<li><p><a class="reference internal" href="#references" id="id38">References</a></p></li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<section id="dr-general-formulation">
<h3>DR General Formulation<a class="headerlink" href="#dr-general-formulation" title="Link to this heading"></a></h3>
<p>DR aims to construct a low-dimensional representation (or embedding) <span class="math notranslate nohighlight">\(\mathbf{Z} = (\mathbf{z}_1, ..., \mathbf{z}_n)^\top\)</span> of an input dataset <span class="math notranslate nohighlight">\(\mathbf{X} = (\mathbf{x}_1, ..., \mathbf{x}_n)^\top\)</span> that best preserves its geometry, encoded via a pairwise affinity matrix <span class="math notranslate nohighlight">\(\mathbf{A_X}\)</span>. To this end, DR methods optimize <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span> such that a pairwise affinity matrix in the embedding space (denoted <span class="math notranslate nohighlight">\(\mathbf{A_Z}\)</span>) matches <span class="math notranslate nohighlight">\(\mathbf{A_X}\)</span>. This general problem is as follows</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{Z}} \: \mathcal{L}( \mathbf{A_X}, \mathbf{A_Z}) \quad \text{(DR)}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> is typically the <span class="math notranslate nohighlight">\(\ell_2\)</span> or cross-entropy loss.
Each DR method is thus characterized by a triplet <span class="math notranslate nohighlight">\((\mathcal{L}, \mathbf{A_X}, \mathbf{A_Z})\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> is structured around the above formulation <span class="math notranslate nohighlight">\(\text{(DR)}\)</span>.
Defining a DR algorithm solely requires providing an <code class="docutils literal notranslate"><span class="pre">Affinity</span></code> object for both input and embedding as well as a loss function <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>.</p>
<p>All modules follow the <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> <a class="footnote-reference brackets" href="#id34" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a> API and can be used in <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html">sklearn pipelines</a>.</p>
</section>
<section id="torch-gpu-support-and-automatic-differentiation">
<h3>Torch GPU support and automatic differentiation<a class="headerlink" href="#torch-gpu-support-and-automatic-differentiation" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> is built on top of <code class="docutils literal notranslate"><span class="pre">PyTorch</span></code> <a class="footnote-reference brackets" href="#id33" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a>, offering GPU support and automatic differentiation. This foundation enables efficient computations and straightforward implementation of new DR methods.</p>
<p>To utilize GPU support, set <code class="xref py py-attr docutils literal notranslate"><span class="pre">device=&quot;cuda&quot;</span></code> when initializing any module. For CPU computations, set <code class="xref py py-attr docutils literal notranslate"><span class="pre">device=&quot;cpu&quot;</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>DR particularly benefits from GPU acceleration as most computations, including affinity calculations and the DR objective, involve matrix reductions that are highly parallelizable.</p>
</div>
</section>
<section id="avoiding-memory-overflows-with-keops-symbolic-lazy-tensors">
<h3>Avoiding memory overflows with <code class="docutils literal notranslate"><span class="pre">KeOps</span></code> symbolic (lazy) tensors<a class="headerlink" href="#avoiding-memory-overflows-with-keops-symbolic-lazy-tensors" title="Link to this heading"></a></h3>
<p>Affinities incur a quadratic memory cost, which can be particularly problematic when dealing with large numbers of samples, especially when using GPUs.</p>
<p>To prevent memory overflows, <code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> relies on <code class="docutils literal notranslate"><span class="pre">KeOps</span></code> <a class="footnote-reference brackets" href="#id32" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a> lazy tensors. These tensors are expressed as mathematical formulas, evaluated directly on the data samples. This symbolic representation allows computations to be performed without storing the entire matrix in memory, thereby effectively eliminating any memory limitation.</p>
<a class="reference internal image-reference" href="_images/symbolic_matrix.svg"><img alt="_images/symbolic_matrix.svg" class="align-center" src="_images/symbolic_matrix.svg" width="800" /></a>
<p>The above figure is taken from <a class="reference external" href="https://github.com/getkeops/keops/blob/main/doc/_static/symbolic_matrix.svg">here</a>.</p>
<p>Set <code class="xref py py-attr docutils literal notranslate"><span class="pre">keops=True</span></code> as input to any module to use symbolic tensors. For small datasets, setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">keops=False</span></code> allows the computation of the full affinity matrix directly in memory.</p>
</section>
</section>
<section id="affinities">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">Affinities</a><a class="headerlink" href="#affinities" title="Link to this heading"></a></h2>
<p>Affinities are the essential building blocks of dimensionality reduction methods.
<code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> provides a wide range of affinities, including basic ones such as <a class="reference internal" href="gen_modules/torchdr.GibbsAffinity.html#torchdr.GibbsAffinity" title="torchdr.GibbsAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">GibbsAffinity</span></code></a>, <a class="reference internal" href="gen_modules/torchdr.StudentAffinity.html#torchdr.StudentAffinity" title="torchdr.StudentAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">StudentAffinity</span></code></a> and <a class="reference internal" href="gen_modules/torchdr.ScalarProductAffinity.html#torchdr.ScalarProductAffinity" title="torchdr.ScalarProductAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarProductAffinity</span></code></a>.</p>
<section id="base-structure">
<h3>Base structure<a class="headerlink" href="#base-structure" title="Link to this heading"></a></h3>
<p>Affinities inherit the structure of the following <a class="reference internal" href="stubs/torchdr.Affinity.html#torchdr.Affinity" title="torchdr.Affinity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Affinity()</span></code></a> class.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/torchdr.Affinity.html#torchdr.Affinity" title="torchdr.Affinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torchdr.Affinity</span></code></a></p></td>
<td><p>Base class for affinity matrices.</p></td>
</tr>
</tbody>
</table>
<p>If computations can be performed in log domain, the <a class="reference internal" href="stubs/torchdr.LogAffinity.html#torchdr.LogAffinity" title="torchdr.LogAffinity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LogAffinity()</span></code></a> class should be used.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/torchdr.LogAffinity.html#torchdr.LogAffinity" title="torchdr.LogAffinity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torchdr.LogAffinity</span></code></a></p></td>
<td><p>Base class for affinity matrices in log space.</p></td>
</tr>
</tbody>
</table>
<p>All affinities have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_transform()</span></code> method that can be used to compute the affinity matrix from a given data matrix. The affinity matrix is a <strong>square matrix of size (n, n)</strong> where n is the number of input samples.</p>
<p>Here is an example with the <a class="reference internal" href="gen_modules/torchdr.GibbsAffinity.html#torchdr.GibbsAffinity" title="torchdr.GibbsAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">GibbsAffinity</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">torchdr</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affinity</span> <span class="o">=</span> <span class="n">torchdr</span><span class="o">.</span><span class="n">GibbsAffinity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affinity_matrix</span> <span class="o">=</span> <span class="n">affinity</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">affinity_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<p>They also have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_batch()</span></code> method that can be called when the affinity is fitted. This method takes as input the indices of the samples that should be in the same batch. It returns the <strong>affinity matrix divided in blocks</strong> given by the batch indices. The output is of size <strong>(n_batch, batch_size, batch_size)</strong> where n_batch is the number of blocks and batch_size is the number of samples per block.</p>
<p>The number of blocks should be a divisor of the number of samples. Here is an example with 5 blocks of size 20 each:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batched_affinity_matrix</span> <span class="o">=</span> <span class="n">affinity</span><span class="o">.</span><span class="n">get_batch</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">batched_affinity_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 20, 20)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In <code class="docutils literal notranslate"><span class="pre">TorchDR</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_batch()</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">KeOps</span></code> (<code class="xref py py-attr docutils literal notranslate"><span class="pre">keops=True</span></code>).
This compatibility allows you to choose the batch size based solely on compute time, without memory limitations.</p>
</div>
</section>
<section id="affinities-based-on-entropic-projections">
<h3>Affinities based on entropic projections<a class="headerlink" href="#affinities-based-on-entropic-projections" title="Link to this heading"></a></h3>
<p>A widely used family of affinities focuses on <strong>controlling the entropy</strong> of the affinity matrix, which is a crucial aspect of SNE-related methods <a class="footnote-reference brackets" href="#id21" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>The first step is to ensure that each point has a unit mass, allowing the affinity matrix to be viewed as a <strong>Markov transition matrix</strong>. An <strong>adaptive bandwidth</strong> parameter then determines how the mass from each point spreads to its neighbors. The bandwidth is based on the <code class="xref py py-attr docutils literal notranslate"><span class="pre">perplexity</span></code> hyperparameter which controls the <strong>number of effective neighbors</strong> for each point.</p>
<p>The resulting affinities can be seen as a <strong>soft approximation of a k nearest neighbor graph</strong> where the <code class="xref py py-attr docutils literal notranslate"><span class="pre">perplexity</span></code> plays the role of k. It allows capturing more subtleties than binary weights. Ultimately, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">perplexity</span></code> is an interpretable hyperparameter that determines which scale of dependencies is represented in the affinity.</p>
<p>The following table details the aspects controlled by various formulations of entropic affinities. <strong>Marginal</strong> refers to the row-wise control of mass. <strong>Entropy</strong> relates to the row-wise control of entropy dictated by the <code class="xref py py-attr docutils literal notranslate"><span class="pre">perplexity</span></code> hyperparameter.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Affinity (associated DR method)</strong></p></th>
<th class="head"><p><strong>Symmetry</strong></p></th>
<th class="head"><p><strong>Marginal</strong></p></th>
<th class="head"><p><strong>Entropy</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a> (<a class="reference internal" href="gen_modules/torchdr.SNE.html#torchdr.SNE" title="torchdr.SNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">SNE</span></code></a>) <a class="footnote-reference brackets" href="#id21" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>❌</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/torchdr.SinkhornAffinity.html#torchdr.SinkhornAffinity" title="torchdr.SinkhornAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinkhornAffinity</span></code></a> (DOSNES) <a class="footnote-reference brackets" href="#id24" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id26" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a></p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
<td><p>❌</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/torchdr.SymmetricEntropicAffinity.html#torchdr.SymmetricEntropicAffinity" title="torchdr.SymmetricEntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricEntropicAffinity</span></code></a> (SNEkhorn) <a class="footnote-reference brackets" href="#id23" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
</tbody>
</table>
<p>More details on these affinities can be found in the <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2023/file/8b54ecd9823fff6d37e61ece8f87e534-Paper-Conference.pdf">SNEkhorn paper</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above table shows that <a class="reference internal" href="gen_modules/torchdr.SymmetricEntropicAffinity.html#torchdr.SymmetricEntropicAffinity" title="torchdr.SymmetricEntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricEntropicAffinity</span></code></a> is the proper symmetric version of <a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a>.
However the l2 symmetrization of <a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a> is more efficient to compute and does not require choosing a learning rate. Hence it can be a useful approximation in practice.</p>
</div>
</section>
<section id="examples-using-entropicaffinity">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">EntropicAffinity</span></code>:<a class="headerlink" href="#examples-using-entropicaffinity" title="Link to this heading"></a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="We show the adaptivity property of entropic affinities on a toy simulated dataset with heterosc..."><img alt="" src="_images/sphx_glr_demo_ea_adaptivity_thumb.png" />
<p><a class="reference internal" href="auto_examples/affinities/demo_ea_adaptivity.html#sphx-glr-auto-examples-affinities-demo-ea-adaptivity-py"><span class="std std-ref">Entropic Affinities can adapt to varying noise levels</span></a></p>
  <div class="sphx-glr-thumbnail-title">Entropic Affinities can adapt to varying noise levels</div>
</div></div></section>
<section id="other-various-affinities">
<h3>Other various affinities<a class="headerlink" href="#other-various-affinities" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> features other affinities that can be used in various contexts.</p>
<p>For instance, the UMAP <a class="footnote-reference brackets" href="#id25" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> algorithm relies on the affinities <a class="reference internal" href="gen_modules/torchdr.UMAPAffinityIn.html#torchdr.UMAPAffinityIn" title="torchdr.UMAPAffinityIn"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMAPAffinityIn</span></code></a> for the input data and <a class="reference internal" href="gen_modules/torchdr.UMAPAffinityOut.html#torchdr.UMAPAffinityOut" title="torchdr.UMAPAffinityOut"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMAPAffinityOut</span></code></a> in the embedding space. <a class="reference internal" href="gen_modules/torchdr.UMAPAffinityIn.html#torchdr.UMAPAffinityIn" title="torchdr.UMAPAffinityIn"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMAPAffinityIn</span></code></a> follows a similar construction as entropic affinities to ensure a constant number of effective neighbors, with <code class="xref py py-attr docutils literal notranslate"><span class="pre">n_neighbors</span></code> playing the role of the <code class="xref py py-attr docutils literal notranslate"><span class="pre">perplexity</span></code> hyperparameter.</p>
<p>Another example is the doubly stochastic normalization of a base affinity under the <span class="math notranslate nohighlight">\(\ell_2\)</span> geometry that has recently been proposed for DR <a class="footnote-reference brackets" href="#id27" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. This method is analogous to <a class="reference internal" href="gen_modules/torchdr.SinkhornAffinity.html#torchdr.SinkhornAffinity" title="torchdr.SinkhornAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinkhornAffinity</span></code></a> where the Shannon entropy is replaced by the <span class="math notranslate nohighlight">\(\ell_2\)</span> norm to recover a sparse affinity.
It is available at <a class="reference internal" href="gen_modules/torchdr.DoublyStochasticQuadraticAffinity.html#torchdr.DoublyStochasticQuadraticAffinity" title="torchdr.DoublyStochasticQuadraticAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyStochasticQuadraticAffinity</span></code></a>.</p>
</section>
</section>
<section id="dr-modules">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">DR Modules</a><a class="headerlink" href="#dr-modules" title="Link to this heading"></a></h2>
<p>All DR estimators inherit the structure of the <a class="reference internal" href="gen_modules/torchdr.DRModule.html#torchdr.DRModule" title="torchdr.DRModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DRModule()</span></code></a> class:</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/torchdr.base.DRModule.html#torchdr.base.DRModule" title="torchdr.base.DRModule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torchdr.base.DRModule</span></code></a></p></td>
<td><p>Base class for DR methods.</p></td>
</tr>
</tbody>
</table>
<p>They are <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code> classes which can be called with the <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> method.</p>
<nav class="contents local" id="id12">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#spectral-methods" id="id39">Spectral methods</a></p></li>
<li><p><a class="reference internal" href="#affinity-matching-methods" id="id40">Affinity matching methods</a></p>
<ul>
<li><p><a class="reference internal" href="#mds-like-methods" id="id41">MDS-like Methods</a></p></li>
<li><p><a class="reference internal" href="#neighbor-embedding" id="id42">Neighbor Embedding</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="spectral-methods">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Spectral methods</a><a class="headerlink" href="#spectral-methods" title="Link to this heading"></a></h3>
<p>Spectral methods correspond to choosing the scalar product affinity <span class="math notranslate nohighlight">\([\mathbf{A_X}]_{ij} = \langle \mathbf{z}_i, \mathbf{z}_j \rangle\)</span> for the embeddings and the <span class="math notranslate nohighlight">\(\ell_2\)</span> loss.</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{Z}} \: \sum_{ij} ( [\mathbf{A_X}]_{ij} - \langle \mathbf{z}_i, \mathbf{z}_j \rangle )^{2}\]</div>
<p>When <span class="math notranslate nohighlight">\(\mathbf{A_X}\)</span> is positive semi-definite, this problem is commonly known as kernel Principal Component Analysis <a class="footnote-reference brackets" href="#id28" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> and an optimal solution is given by</p>
<div class="math notranslate nohighlight">
\[\mathbf{Z}^{\star} = (\sqrt{\lambda_1} \mathbf{v}_1, ..., \sqrt{\lambda_d} \mathbf{v}_d)^\top\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_1, ..., \lambda_d\)</span> are the largest eigenvalues of the centered kernel matrix <span class="math notranslate nohighlight">\(\mathbf{A_X}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}_1, ..., \mathbf{v}_d\)</span> are the corresponding eigenvectors.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PCA (available at <a class="reference internal" href="gen_modules/torchdr.PCA.html#torchdr.PCA" title="torchdr.PCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">torchdr.PCA</span></code></a>) corresponds to choosing <span class="math notranslate nohighlight">\([\mathbf{A_X}]_{ij} = \langle \mathbf{x}_i, \mathbf{x}_j \rangle\)</span>.</p>
</div>
</section>
<section id="affinity-matching-methods">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Affinity matching methods</a><a class="headerlink" href="#affinity-matching-methods" title="Link to this heading"></a></h3>
<p>Outside of spectral methods, a closed-form solution to the DR problem is typically not available. The problem can then be solved using <a class="reference external" href="https://pytorch.org/docs/stable/optim.html">gradient-based optimizers</a>.</p>
<p>The following classes serve as parent classes for this approach, requiring the user to provide affinity objects for the input and output spaces, referred to as <code class="xref py py-attr docutils literal notranslate"><span class="pre">affinity_in</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">affinity_out</span></code>.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="stubs/torchdr.affinity_matcher.AffinityMatcher.html#torchdr.affinity_matcher.AffinityMatcher" title="torchdr.affinity_matcher.AffinityMatcher"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torchdr.affinity_matcher.AffinityMatcher</span></code></a></p></td>
<td><p>Performs dimensionality reduction by matching two affinity matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stubs/torchdr.affinity_matcher.BatchedAffinityMatcher.html#torchdr.affinity_matcher.BatchedAffinityMatcher" title="torchdr.affinity_matcher.BatchedAffinityMatcher"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torchdr.affinity_matcher.BatchedAffinityMatcher</span></code></a></p></td>
<td><p>Performs dimensionality reduction by matching two batched affinity matrices.</p></td>
</tr>
</tbody>
</table>
<p>We now present two families of such DR methods: those based on the <span class="math notranslate nohighlight">\(\ell_2\)</span> loss (similar to MDS methods) and those based on the cross-entropy loss (neighbor embedding methods).</p>
<section id="mds-like-methods">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">MDS-like Methods</a><a class="headerlink" href="#mds-like-methods" title="Link to this heading"></a></h4>
<p>They relie on the square loss between (squared) distance matrices <span class="math notranslate nohighlight">\(\mathbf{D_X}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{D_Z}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{Z}} \: \sum_{ij} ( [\mathbf{D_X}]_{ij} - [\mathbf{D_Z}]_{ij} )^{2}\]</div>
</section>
<section id="neighbor-embedding">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Neighbor Embedding</a><a class="headerlink" href="#neighbor-embedding" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">TorchDR</span></code> aims to implement most popular <strong>neighbor embedding (NE)</strong> algorithms.
In this section we briefly go through the main NE algorithms and their variants.</p>
<p>For consistency with the literature, we will denote the input affinity matrix by <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> and the output affinity matrix by <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span>. These affinities can be viewed as <strong>soft neighborhood graphs</strong>, hence the term <em>neighbor embedding</em>.</p>
<section id="overview-of-ne-via-attraction-and-repulsion">
<h5>Overview of NE via Attraction and Repulsion<a class="headerlink" href="#overview-of-ne-via-attraction-and-repulsion" title="Link to this heading"></a></h5>
<p>NE objectives share a common structure: they aim to minimize the weighted sum of an attractive term and a repulsive term. Interestingly, the attractive term is often the cross-entropy between the input and output affinities. Additionally, the repulsive term is typically a function of the output affinities only. Thus, the NE problem can be formulated as the following minimization problem:</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{Z}} \: - \sum_{ij} P_{ij} \log Q_{ij} + \gamma \mathcal{L}_{\mathrm{rep}}(\mathbf{Q}) \:.\]</div>
<p>In the above, <span class="math notranslate nohighlight">\(\mathcal{L}_{\mathrm{rep}}(\mathbf{Q})\)</span> represents the repulsive part of the loss function while <span class="math notranslate nohighlight">\(\gamma\)</span> is a hyperparameter that controls the balance between attraction and repulsion.</p>
<p>Many NE methods can be represented within this framework. The following table summarizes the ones implemented in <code class="docutils literal notranslate"><span class="pre">TorchDR</span></code>, detailing their respective repulsive loss function, as well as their input and output affinities.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Method</strong></p></th>
<th class="head"><p><strong>Repulsive term</strong> <span class="math notranslate nohighlight">\(\mathcal{L}_{\mathrm{rep}}\)</span></p></th>
<th class="head"><p><strong>Affinity input</strong> <span class="math notranslate nohighlight">\(\mathbf{P}\)</span></p></th>
<th class="head"><p><strong>Affinity output</strong> <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/torchdr.SNE.html#torchdr.SNE" title="torchdr.SNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">SNE</span></code></a> <a class="footnote-reference brackets" href="#id21" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\sum_{i} \log(\sum_j Q_{ij})\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.GibbsAffinity.html#torchdr.GibbsAffinity" title="torchdr.GibbsAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">GibbsAffinity</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/torchdr.TSNE.html#torchdr.TSNE" title="torchdr.TSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">TSNE</span></code></a> <a class="footnote-reference brackets" href="#id22" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\log(\sum_{ij} Q_{ij})\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.StudentAffinity.html#torchdr.StudentAffinity" title="torchdr.StudentAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">StudentAffinity</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/torchdr.InfoTSNE.html#torchdr.InfoTSNE" title="torchdr.InfoTSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">InfoTSNE</span></code></a> <a class="footnote-reference brackets" href="#id30" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\log(\sum_{(ij) \in B} Q_{ij})\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.StudentAffinity.html#torchdr.StudentAffinity" title="torchdr.StudentAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">StudentAffinity</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gen_modules/torchdr.SNEkhorn.html#torchdr.SNEkhorn" title="torchdr.SNEkhorn"><code class="xref py py-class docutils literal notranslate"><span class="pre">SNEkhorn</span></code></a> <a class="footnote-reference brackets" href="#id23" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\sum_{ij} Q_{ij}\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.SymmetricEntropicAffinity.html#torchdr.SymmetricEntropicAffinity" title="torchdr.SymmetricEntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricEntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.SinkhornAffinity.html#torchdr.SinkhornAffinity" title="torchdr.SinkhornAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinkhornAffinity(base_kernel=&quot;gaussian&quot;)</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gen_modules/torchdr.TSNEkhorn.html#torchdr.TSNEkhorn" title="torchdr.TSNEkhorn"><code class="xref py py-class docutils literal notranslate"><span class="pre">TSNEkhorn</span></code></a> <a class="footnote-reference brackets" href="#id23" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(\sum_{ij} Q_{ij}\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.SymmetricEntropicAffinity.html#torchdr.SymmetricEntropicAffinity" title="torchdr.SymmetricEntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricEntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.SinkhornAffinity.html#torchdr.SinkhornAffinity" title="torchdr.SinkhornAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinkhornAffinity(base_kernel=&quot;student&quot;)</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>UMAP <a class="footnote-reference brackets" href="#id25" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(- \sum_{ij} \log (1 - Q_{ij})\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.UMAPAffinityIn.html#torchdr.UMAPAffinityIn" title="torchdr.UMAPAffinityIn"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMAPAffinityIn</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.UMAPAffinityOut.html#torchdr.UMAPAffinityOut" title="torchdr.UMAPAffinityOut"><code class="xref py py-class docutils literal notranslate"><span class="pre">UMAPAffinityOut</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>LargeVis <a class="footnote-reference brackets" href="#id29" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(- \sum_{ij} \log (1 - Q_{ij})\)</span></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.EntropicAffinity.html#torchdr.EntropicAffinity" title="torchdr.EntropicAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntropicAffinity</span></code></a></p></td>
<td><p><a class="reference internal" href="gen_modules/torchdr.StudentAffinity.html#torchdr.StudentAffinity" title="torchdr.StudentAffinity"><code class="xref py py-class docutils literal notranslate"><span class="pre">StudentAffinity</span></code></a></p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id14">3</a>)</span>
<p>Geoffrey Hinton, Sam Roweis (2002). <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2002/file/6150ccc6069bea6b5716254057a194ef-Paper.pdf">Stochastic Neighbor Embedding</a>. Advances in Neural Information Processing Systems 15 (NeurIPS).</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">2</a><span class="fn-bracket">]</span></span>
<p>Laurens van der Maaten, Geoffrey Hinton (2008). <a class="reference external" href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf?fbcl">Visualizing Data using t-SNE</a>. The Journal of Machine Learning Research 9.11 (JMLR).</p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id17">2</a>,<a role="doc-backlink" href="#id18">3</a>)</span>
<p>Hugues Van Assel, Titouan Vayer, Rémi Flamary, Nicolas Courty (2023). <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2023/file/8b54ecd9823fff6d37e61ece8f87e534-Paper-Conference.pdf">SNEkhorn: Dimension Reduction with Symmetric Entropic Affinities</a>. Advances in Neural Information Processing Systems 36 (NeurIPS).</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>Richard Sinkhorn, Paul Knopp (1967). <a class="reference external" href="https://msp.org/pjm/1967/21-2/pjm-v21-n2-p14-p.pdf">Concerning nonnegative matrices and doubly stochastic matrices</a>. Pacific Journal of Mathematics, 21(2), 343-348.</p>
</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id10">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p>Leland McInnes, John Healy, James Melville (2018). <a class="reference external" href="https://arxiv.org/abs/1802.03426">UMAP: Uniform manifold approximation and projection for dimension reduction</a>. arXiv preprint arXiv:1802.03426.</p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">9</a><span class="fn-bracket">]</span></span>
<p>Yao Lu, Jukka Corander, Zhirong Yang (2019). <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0167865518305099">Doubly Stochastic Neighbor Embedding on Spheres</a>. Pattern Recognition Letters 128 : 100-106.</p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">10</a><span class="fn-bracket">]</span></span>
<p>Stephen Zhang, Gilles Mordant, Tetsuya Matsumoto, Geoffrey Schiebinger (2023). <a class="reference external" href="https://arxiv.org/abs/2307.09816">Manifold Learning with Sparse Regularised Optimal Transport</a>. arXiv preprint.</p>
</aside>
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">11</a><span class="fn-bracket">]</span></span>
<p>Ham, J., Lee, D. D., Mika, S., &amp; Schölkopf, B. (2004). <a class="reference external" href="https://icml.cc/Conferences/2004/proceedings/papers/296.pdf">A kernel view of the dimensionality reduction of manifolds</a>. In Proceedings of the twenty-first international conference on Machine learning (ICML).</p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">13</a><span class="fn-bracket">]</span></span>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016). <a class="reference external" href="https://dl.acm.org/doi/pdf/10.1145/2872427.2883041?casa_token=9ybi1tW9opcAAAAA:yVfVBu47DYa5_cpmJnQZm4PPWaTdVJgRu2pIMqm3nvNrZV5wEsM9pde03fCWixTX0_AlT-E7D3QRZw">Visualizing Large-Scale and High-Dimensional Data</a>. In Proceedings of the 25th international conference on world wide web.</p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">15</a><span class="fn-bracket">]</span></span>
<p>Sebastian Damrich, Jan Niklas Böhm, Fred Hamprecht, Dmitry Kobak (2023). <a class="reference external" href="https://openreview.net/pdf?id=B8a1FcY0vi">From t-SNE to UMAP with contrastive learning</a>. International Conference on Learning Representations (ICLR).</p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></span>
<p>Hugues Van Assel, Thibault Espinasse, Julien Chiquet, &amp; Franck Picard (2022). <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2022/file/45994782a61bb51cad5c2bae36834265-Paper-Conference.pdf">A Probabilistic Graph Coupling View of Dimension Reduction</a>. Advances in Neural Information Processing Systems 35 (NeurIPS).</p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">19</a><span class="fn-bracket">]</span></span>
<p>Charlier, B., Feydy, J., Glaunes, J. A., Collin, F. D., &amp; Durif, G. (2021). <a class="reference external" href="https://www.jmlr.org/papers/volume22/20-275/20-275.pdf">Kernel Operations on the GPU, with Autodiff, without Memory Overflows</a>. Journal of Machine Learning Research (JMLR).</p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">20</a><span class="fn-bracket">]</span></span>
<p>Paszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., … &amp; Chintala, S. (2019). <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2019/file/bdbca288fee7f92f2bfa9f7012727740-Paper.pdf">Pytorch: An imperative style, high-performance deep learning library</a>. Advances in neural information processing systems 32 (NeurIPS).</p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">21</a><span class="fn-bracket">]</span></span>
<p>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., … &amp; Duchesnay, É. (2011). <a class="reference external" href="https://www.jmlr.org/papers/volume12/pedregosa11a/pedregosa11a.pdf?ref=https:/">Scikit-learn: Machine learning in Python</a>. Journal of machine Learning research, 12 (JMLR).</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="torchdr.quick_start.html" class="btn btn-neutral float-left" title="Quick Start Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="stubs/torchdr.Affinity.html" class="btn btn-neutral float-right" title="Affinity" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, TorchDR team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>